[{"title":"MAC系统下更改host文件","date":"2015-07-27T12:08:34.000Z","path":"2015/07/27/MAC系统下更改host文件/","text":"##1.终端更改 1.在应用程序里面打开终端(terminal) 2.输入sudo vi /etc/hosts 3.提示输入系统密码(输入密码是默认隐藏的，直接输入回车)hosts文件 就自动打开了(有时候打不开,在敲次回车) 4.打开此网站生成host文件: http://serve.netsh.org/pub/gethosts.php 5.接着输入 i 进入编辑模式将添加的网站,ip拷贝进去 6.编辑完成之后,按esc,输入 : wq ##2.直接修改本地文件 1.打开finder ,在前往里面选择前往文件夹(快捷键shift+comman+g) 在弹出框里输入 /private/etc 2.到了etc目录下,找到hosts文件 4.打开此网站生成host文件: http://serve.netsh.org/pub/gethosts.php 4.打开(用文本编辑),拷贝或编辑,完成后保存即可.(一般会提示输入管理 员密码,输入完成保存即可)","tags":[]},{"title":"简单制作 OS X Yosemite 10.10 正式版U盘USB启动安装盘方法教程","date":"2015-07-27T12:08:34.000Z","path":"2015/07/27/简单制作 OS X Yosemite 10.10 正式版U盘USB启动安装盘方法教程/","text":"#本文讲解的是用命令行制作 一.准备工作1.准备一个 8GB 或以上容量的 U 盘，确保里面的数据已经妥善备份好（该过程会抹掉 U 盘全部数据） 2.从这里下载苹果官方 OS X Yosemite 正式版的安装程序 3.如果你是从 Mac AppStore 下载的，下载完成后安装程序可能自动开始，这时先退出安装 4.把下载完的系统移动到「应用程序」文件夹里面 二.格式化U盘 插入你的 U 盘，然后在「应用程序」-&gt;「实用工具」里面找到并打开「磁盘工具」如下图。 1 - 在左方列表中找到 U 盘的名称并点击 右边顶部选择 2 -「分区」，然后在 3 -「分区布局」选择「1个分区」 在分区信息中的 4 -「名称」输入「iPlaySoft」 (名字随便起,因为在后面的命令行用到) 在「格式」中选择 5 -「Mac OS 扩展 (日志式)」. 在 6 -「选项」里面，如下图 6.选择「GUID 分区表」，然后点击「好」 7.最后再点「应用」开始对 U 盘进行格式化。 三、输入终端命令开始制作启动盘 请再次确保名为 “安装 OS X Yosemite” 的文件是保存在「应用程序」的目录中 在「应用程序」-&gt;「实用工具」里面找到「终端」并打开。 复制下面的命令，并粘贴到「终端」里，按回车运行： 1sudo /Applications/Install\\ OS\\ X\\ Yosemite.app/Contents/Resources/createinstallmedia --volume /Volumes/iPlaySoft --applicationpath /Applications/Install\\ OS\\ X\\ Yosemite.app --nointeraction 回车后，系统会提示你输入管理员密码，接下来就是等待系统开始制作启动盘了,会如下提示就说明已经完成了 1234567Erasing Disk: 0%... 10%... 20%... 30%...100%...Copying installer files to disk...Copy complete.Making disk bootable...Copying boot files...Copy complete.Done. 四.U 盘启动安装系统 开机一直按住「option」(alt) 按键不放,后面步骤不详细介绍","tags":[{"name":"blog","slug":"blog","permalink":"http://once00.github.io/tags/blog/"}]},{"title":"CocoaPods安装和使用教程","date":"2015-01-21T04:07:19.000Z","path":"2015/01/21/CocoaPods安装和使用教程/","text":"##如何下载和安装CocoaPods？我们可以用淘宝的Ruby镜像来访问cocoapods。按照下面的顺序在终端中敲入依次敲入命令： 1$ gem sources --remove https://rubygems.org/ 等有反应之后再敲入以下命令 1$ gem sources -a http://ruby.taobao.org/ 为了验证你的Ruby镜像是并且仅是taobao，可以用以下命令查看： 1$ gem sources -l 只有在终端中出现下面文字才表明你上面的命令是成功的：123*** CURRENT SOURCES ***&lt;!-- more --&gt;http://ruby.taobao.org/ 再次在终端中运行： 1$ sudo gem install cocoapods 系统会提示输入管理员密码(如果没密码,请设置一个密码) 等待输入完成时候如果是如下提示,则是成功的表现 12345678910Installing ri documentation for cocoapods-trunk-0.4.1Parsing documentation for molinillo-0.1.2Installing ri documentation for molinillo-0.1.2Parsing documentation for escape-0.0.4Installing ri documentation for escape-0.0.4Parsing documentation for open4-1.3.4Installing ri documentation for open4-1.3.4Parsing documentation for cocoapods-0.35.0Installing ri documentation for cocoapods-0.35.020 gems installed ##如果安装第三方类库 ###如在项目中导入AFNetworking类库:为了确定AFNetworking是否支持CocoaPods，可以用CocoaPods的搜索功能验证一下。在终端中输入： 1$ pod search AFNetworking 等待几秒就能看到如下提示 1234567891011121314151617-&gt; AFNetworking (2.5.0) A delightful iOS and OS X networking framework. pod 'AFNetworking', '~&gt; 2.5.0' - Homepage: https://github.com/AFNetworking/AFNetworking - Source: https://github.com/AFNetworking/AFNetworking.git - Versions: 2.5.0, 2.4.1, 2.4.0, 2.3.1, 2.3.0, 2.2.4, 2.2.3, 2.2.2, 2.2.1, 2.2.0, 2.1.0, 2.0.3, 2.0.2, 2.0.1, 2.0.0, 2.0.0-RC3, 2.0.0-RC2, 2.0.0-RC1, 1.3.4, 1.3.3, 1.3.2, 1.3.1, 1.3.0, 1.2.1, 1.2.0, 1.1.0, 1.0.1, 1.0, 1.0RC3, 1.0RC2, 1.0RC1, 0.10.1, 0.10.0, 0.9.2, 0.9.1, 0.9.0, 0.7.0, 0.5.1 [master repo] - Sub specs: - AFNetworking/Serialization (2.5.0) - AFNetworking/Security (2.5.0) - AFNetworking/Reachability (2.5.0) - AFNetworking/NSURLConnection (2.5.0) - AFNetworking/NSURLSession (2.5.0) - AFNetworking/UIKit (2.5.0) **此时新建一个项目,在终端中输入命令进入你的项目目录输入: 1pod init 此时你的项目目录里面多了Podfile文件,用文本编辑模式打开,输入刚验证的版本号:pod &#39;AFNetworking&#39;, &#39;~&gt; 2.5.0&#39; 这时候，你就可以利用CocoPods下载AFNetworking类库了。还是在终端中的当前项目目录下，运行以下命令： 1$ pod install 因为是在你的项目中导入AFNetworking，这就是为什么这个命令需要你进入你的项目所在目录中运行。 运行上述命令之后，小编的终端出现以下信息: 123456789101112131415Analyzing dependenciesCocoaPods 0.36.0.beta.1 is available.To update use: `gem install cocoapods --pre`[!] This is a test version we'd love you to try.For more information see http://blog.cocoapods.organd the CHANGELOG for this version http://git.io/BaH8pQ.Downloading dependenciesInstalling AFNetworking (2.5.0)Generating Pods projectIntegrating client project[!] From now on use `CocoaPods.xcworkspace`. **注意最后一句话，意思是：以后打开项目就用 CocoaPodsDemo.xcworkspace 打开，而不是之前的.xcodeproj文件。","tags":[]},{"title":"UploadImageByAFNetworking","date":"2015-01-20T09:08:16.000Z","path":"2015/01/20/UploadImageByAFNetworking/","text":"准备工作：界面放置UIImageView，设置默认的图片属性，生成相应的输出口，声明图像选取器(UIImagePickerController)属性，然后在viewDidLoad方法中添加如下代码： 给图像视图添加轻拍手势 设置手势属性：一个手指单击一次 给界面图像视图绑定手势 设置界面图像视图能够与用户交互 初始化图像选取控制器 设置图像选取器的委托 参考代码： 1.给图像视图添加轻拍手势 UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tapImage:)]; 2.设置手势属性：一个手指单击一次 tap.numberOfTapsRequired = 1; tap.numberOfTouchesRequired = 1; 3.给界面图像视图绑定手势 [self.imageView addGestureRecognizer:tap]; 4.设置界面图像视图能够与用户交互 self.imageView.userInteractionEnabled = YES; 5.初始化图像选取控制器 self.imagePicker = [UIImagePickerController new]; 6.设置图像选取器的委托 self.imagePicker.delegate = self; 完成以下方法： #pragma mark 单击界面图像视图调用的方法 - (void)tapImage:(UIGestureRecognizer *)recognizer { // 打开图片库选取图片 } 123 ``` #pragma mark 图像选取控制器委托方法 - (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info &#123; // 从info字典参数中获取选中的图片（通过UIImagePickerControllerOriginalImage键获取） // 设置界面imageView的image属性为选中的图片 // 关闭图片库 &#125; ``` **参考代码：** ``` #pragma mark 单击界面图像视图调用的方法 - (void)tapImage:(UIGestureRecognizer *)recognizer &#123; // 打开图片库选取图片 [self presentViewController:self.imagePickerController animated:YES completion:nil]; &#125; #pragma mark 图像选取控制器委托方法 (void)imagePickerController:(UIImagePickerController )picker didFinishPickingMediaWithInfo:(NSDictionary )info { // 从info字典参数中获取选中的图片（通过UIImagePickerControllerOriginalImage键获取） UIImage * image=info[UIImagePickerControllerOriginalImage]; // 设置界面imageView的image属性为选中的图片 self.imageView.image=image; // 关闭图片库 [self dismissViewControllerAnimated:YES completion:nil]; } **完成上传图片，使用AFNetworking** (IBAction)uploadImage:(id)sender { // 把图片对象转换成data对象（UIImagePNGRepresentation方法） // 保存图片到沙盒中（获取文件完整目录，使用data对象的writeToFile:atomically: 方法写入） // 使用AFNetworking上传图片 // 创建http请求操作管理器（AFHTTPRequestOperationManager类的对象） // 设置接收响应类型 //manager.responseSerializer.acceptableContentTypes = [NSSetsetWithObjects:@”text/html”, nil]; // 使用AFHTTPRequestOperationManager类的对象POST:parameters: constructingBodyWithBlock: success: failure:方法创建http请求操作对象 (AFHTTPRequestOperation) constructingBodyWithBlock代码块参数中执行以下代码： // 文件路径方式上传图片 // 通过沙盒中文件完整路径创建NSURL对象（NSURL 的类方法fileURLWithPath:） // 调用代码块的formData参数的appendPartWithFileURL: name:error:方法 上传图片（注意此处name参数是服务端上传图片时接口中的参数名称） // data方式上传图片 /*[formData appendPartWithFileData:imageData name:@&quot;fileName&quot; fileName:@&quot;upload.png&quot; mimeType:@&quot;image/png&quot;];*/ //最后http请求操作对象发送请求 **参考代码：** **//上传图片，使用AFNetworking** **- (IBAction)uploadImage:(id)sender {** 1.把图片对象转换成data对象(UIImagePNGRepresentation方法） NSData *imageData = UIImagePNGRepresentation(self.imageView.image);1234 2.保存图片到沙盒中 ``` NSString *filePath = [self getFilePath:@\"upload.png\"];[imageData writeToFile:filePath atomically:YES];``` 3.使用AFNetworking上传图片 // 创建http请求操作管理器（AFHTTPRequestOperationManager类的对象） AFHTTPRequestOperationManager * manage=[AFHTTPRequestOperationManager new]; 4.创建http请求操作管理器(AFHTTPRequestOperationManager类的对象） AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager new]; 5.设置接收响应类型 manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@”text/html”, nil]; 6.创建http请求操作对象 AFHTTPRequestOperation op = [manager POST:kUploadFileURL parameters:nil constructingBodyWithBlock:^(id formData) {*菊花[MMProgressHUD setPresentationStyle:MMProgressHUDPresentationStyleFade];[MMProgressHUD showWithTitle:@”上传图片” status:@”上传中。。。”];1234567 7.文件路径方式上传图片 ``` NSURL *url = [NSURL fileURLWithPath:filePath]; [formData appendPartWithFileURL:url name:@\"fileName\" error:nil]; ``` 8.data方式上传图片 ``` [formData appendPartWithFileData:imageData name:@\"fileName\" fileName:@\"upload.png\" mimeType:@\"image/png\"];*/ &#125; success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; [MMProgressHUD dismissWithSuccess:@\"上传成功！\"]; NSLog(@\"responseObject:%@\",responseObject); &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; [MMProgressHUD dismissWithError:@\"上传失败！\"]; NSLog(@\"error:%@\",[error localizedDescription]); &#125;];``` 8.http请求操作对象发送请求 ``` [op start];``` &#125;","tags":[]},{"title":"Xcode6 使用MJRefresh，Too many arguments to function call, expected 0, have *","date":"2015-01-20T08:50:06.000Z","path":"2015/01/20/Xcode6-使用MJRefresh，Too-many-arguments-to-function-call-expected-0-have/","text":"将Xcode升级到6后，报Too many arguments to function call, expected 0, have *，在Xcode5.1里能编译通过的，到Xcode6就报错 objc_msgSend(self.beginRefreshingTaget, self.beginRefreshingAction, self); Too many arguments to function call, expected 0, have * 选中项目 - Project - Build Settings - ENABLE_STRICT_OBJC_MSGSEND 将其设置为 NO 即可 如果编译还是出现错误,修改MJRefreshConst.m,在文件头部添加一下代码即可: #import &lt;CoreGraphics/CoreGraphics.h&gt;","tags":[]},{"title":"初学SQLite","date":"2015-01-16T10:28:51.000Z","path":"2015/01/16/初学SQLite/","text":"SQLite 是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 其特点是高度便携、使用方便、结构紧凑、高效、可靠。 与其他数据库管理系统不同，SQLite 的安装和运行非常简单，在大多数情况下 - 只要确保SQLite的二进制文件存在即可开始创建、连接和使用数据库。如果您正在寻找一个嵌入式数据库项目或解决方案，SQLite是绝对值得考虑。 ##SQLite on Mac OS X如果你正在使用 Mac OS 雪豹或者更新版本的系统，那么系统上已经装有 SQLite 了。 ####创建首个 SQLite 数据库现在你已经安装了 SQLite 数据库，接下来我们创建首个数据库。在命令行窗口中输入如下命令来创建一个名为 test.db 的数据库(如果数据库存在则进入数据库).1$ sqlite3 test.db 进入了sqlite3之后，会看到以下文字： 1SQLite version 3.7.12 2012-04-03 19:43:07 Enter \".help\" for instructions Enter SQL statements terminated with a \";\" sqlite&gt; 这时如果使用.help可以取得求助，.quit则是离开 ####创建表 $ sqlite&gt; create table mytable(id integer primary key, value text); 12 * 该表包含一个名为 id 的主键字段和一个名为 value 的文本字段。 ####往表里中写入一些数据 sqlite&gt; insert into mytable(id, value) values(1, &apos;Micheal&apos;); sqlite&gt; insert into mytable(id, value) values(2, &apos;Jenny&apos;); sqlite&gt; insert into mytable(value) values(&apos;Francis&apos;); sqlite&gt; insert into mytable(value) values(&apos;Kerk&apos;); 1 ####查询数据 sqlite&gt; select * from test; 1 * 结果显示如下: 1|Micheal 2|Jenny 3|Francis 4|Kerk 1 **设置格式化查询结果:** sqlite&gt; .mode column sqlite&gt; .header on sqlite&gt; select * from test; 显示结果如下 1id value ----------- ------------- 1 Micheal 2 Jenny 3 Francis 4 Kerk .mode column 将设置为列显示模式，.header on将显示列名 ####修改表 修改表结构，增加列 1sqlite&gt; alter table mytable add column email text not null '' collate nocase;; ####创建视图 1sqlite&gt; create view nameview as select * from mytable; ####创建索引 1sqlite&gt; create index test_idx on mytable(value); ####一些有用的 SQLite 命令(命令最后不用加分号) 显示表结构 1$ sqlite&gt; .schema [tablename] 获取所有表和视图 1$ sqlite&gt; .schema [tablename] 获取指定表的索引列表 1$ sqlite &gt; .indices [table ] 导出数据库到 SQL 文件 1 $ sqlite &gt; .output [filename ] $ sqlite &gt; .dump $ sqlite &gt; .output stdout 从 SQL 文件导入数据库 1$ sqlite &gt; .read [filename ] 格式化输出数据到 CSV 格式 1234$ sqlite &gt;.output [filename.csv ] $ sqlite &gt;.separator $ sqlite &gt; select * from test; $ sqlite &gt;.output stdout 从 CSV 文件导入数据到表中 12 $ sqlite &gt;create table newtable ( id integer primary key, value text ); $ sqlite &gt;.import [filename.csv ] newtable 备份数据库 $ sqlite3 mytable.db .dump &gt; backup.sql 恢复数据库 $ sqlite3 mytable.db &lt; backup.sql","tags":[]},{"title":"给博客绑定域名","date":"2015-01-16T09:59:17.000Z","path":"2015/01/16/给博客绑定域名/","text":"博客搭建好之后主要还是想有自己的网址 ##具体配置如下 A类型的主要是填写自己博客IP地址(可在站长工具中查询自己的IP地址) CNAME记录主要填写自己的博客地址 在自己soure新建一个CNAME文件,在里面填写自己的博客地址如果想使用www.zipperary.com形式，CNAME文件中相应地变为www.onceoo.com即可","tags":[]},{"title":"Hexo详细目录分析","date":"2015-01-16T09:18:59.000Z","path":"2015/01/16/Hexo详细目录分析/","text":"##目录和文件默认生成的一些文件 scaffolds 脚手架，也就是一个工具模板 scripts 写文件的js，扩展hexo的功能 source 存放博客正文内容 source/_drafts 草稿箱 source/_posts 文件箱 themes 存放皮肤的目录 themes/landscape 默认的皮肤 _config.yml 全局的配置文件 db.json 静态常量 ##全局配置 站点配置用到两个文件，一个是对整站的配置H:\\hexo_config.yml，另一个是对主题的配置H:\\hexo\\themes\\light_config.yml ###H:\\hexo_config.yml下文件 这是全局配置文件,网站很多东西都需要在这里配置 站点信息: 定义标题，作者，语言 URL: URL访问路径 文件目录: 正文的存储目录 写博客配置：文章标题，文章类型，外部链接等 目录和标签：默认分类，分类图，标签图 归档设置：归档的类型 服务器设置：IP，访问端口，日志输出 时间和日期格式： 时间显示格式，日期显示格式 分页设置：每页显示数量 评论：外挂的Disqus评论系统 插件和皮肤：换皮肤，安装插件 Markdown语言：markdown的标准 CSS的stylus格式：是否允许压缩 部署配置：github发布 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/tommy351/hexo/# 整站的基本信息title: #网站标题subtitle: #网站副标题description: blog.fens.me #对站点的描述author: bsspirit #在站点左下角可以看到email: bsspirit@gmail.com #邮箱language: zh-CN #语言# URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://blog.fens.meroot: /permalink: :year/:month/:day/:title/tag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/code# 文件目录source_dir: sourcepublic_dir: public# 写博客配置(文章布局.写作格式的定义)new_post_name: :title.md # File name of new postsdefault_layout: postauto_spacing: false # Add spaces between asian characters and western characterstitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabmax_open_file: 100multi_thread: truefilename_case: 0render_drafts: falsepost_asset_folder: falsehighlight: enable: true line_number: true tab_replace:# 目录和标签default_category: uncategorizedcategory_map:tag_map:# 归档设置## 2: Enable pagination## 1: Disable pagination## 0: Fully Disable#默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文archive: 2category: 2tag: 2# 服务器设置## Hexo uses Connect as a server## You can customize the logger format as defined in## http://www.senchalabs.org/connect/logger.htmlport: 4000server_ip: 0.0.0.0logger: falselogger_format:# 时间和日期格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: MMM D YYYYtime_format: H:mm:ss# 分页设置(每页显示文章数,可以自定义)## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# 评论disqus_shortname:# 插件和皮肤## Plugins: https://github.com/tommy351/hexo/wiki/Plugins## Themes: https://github.com/tommy351/hexo/wiki/Themestheme: landscapeexclude_generator:# Markdown语法## https://github.com/chjj/markedmarkdown: gfm: true pedantic: false sanitize: false tables: true breaks: true smartLists: true smartypants: true# CSS的stylus格式stylus: compress: false# 部署配置## Docs: http://hexo.io/docs/deployment.htmldeploy: type: repository: #自己博客地址 branch: master ###H:\\hexo\\themes\\light_config.yml目录下 ####页面展示的全部逻辑都在每个主题控制 123456789101112131415161718.├── languages #多语言| ├── default.yml#默认语言| └── zh-CN.yml #中文语言├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _partial #局部的布局，此目录下的*.ejs是对头尾等局部的控制| └── _widget#小挂件的布局，页面下方小挂件的控制├── source #源码| ├── css#css源码 | | ├── _base #*.styl基础css| | ├── _partial #*.styl局部css| | ├── fonts #字体| | ├── images #图片| | └── style.styl #*.styl引入需要的css源码| ├── fancybox #fancybox效果源码| └── js #javascript源代码├── _config.yml#主题配置文件└── README.md #用GitHub的都知道 ####light_config.yml文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# Headermenu: 主页: / 所有文章: /archives 随笔: /tags# SubNavsubnav: github: \"https://github.com/once00\" weibo: \"http://weibo.com/5253699523/profile?topnav=1&amp;wvr=6\" rss: \"#\" facebook: \"#\" # google: \"#\" # twitter: \"#\" # linkedin: \"#\"rss: /atom.xml# Contentexcerpt_link: morefancybox: true# Miscellaneousgoogle_analytics: ''favicon: /favicon.png#你的头像avatar: \"https://raw.githubusercontent.com/once00/once00.github.io/master/img/8552641.jpeg\"#是否开启分享share: true#是否开启多说评论，填写你在多说申请的项目名称#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论duoshuo: true#是否开启云标签tagcloud: true#是否开启友情链接#不开启——#friends: false#开启——friends: 卡卡的美丽传说: http://localhost:4000/ 本泽马的博客: http://localhost:4000/ 吉格斯的博客: http://localhost:4000/ 习大大大不同: http://localhost:4000/ 托蒂的博客: http://localhost:4000/#是否开启“关于我”。#不开启——#aboutme: false#开启——aboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货… ##查看命令行帮助 1$ hexo help 12345678910111213141516Usage: hexo Commands: help Get help on a command init Create a new Hexo folder migrate Migrate your site from other system to Hexo version Display version informationGlobal Options: --config Specify config file instead of using _config.yml --debug Display all verbose messages in the terminal --safe Disable all plugins and scripts --silent Hide output on consoleFor more help, you can use `hexo help [command]` for the detailed informationor you can check the docs: http://hexo.io/docs/ 命令行解释： help 查看帮助信息 init 创建一个hexo项目 migrate 从其他系统向hexo迁移 version 查看hexo的版本 –config参数，指定配置文件，代替默认的_config.yml –debug参数，调试模式，输出所有日志信息 –safe参数，安全模式，禁用所有的插件和脚本 –silent参数，无日志输出模式","tags":[]},{"title":"hexo搭建","date":"2015-01-16T06:13:16.000Z","path":"2015/01/16/hexo搭建/","text":"##一.安装Hexo 打开终端 1$ npm install -g hexo ##二.部署Hexo 在电脑任意位置新建文件夹利用终端进入此文件夹.执行此命令(Hexo随后会自动在目标文件夹建立网站所需要的所有文件). 1$ hexo init 必须执行此命令才可被保存 1$ hexo generate 可把hexo generate简写为hexo g 启动Hexo服务器 1$ hexo server 可把hexo server简写为hexo s 这时端口4000被打开了，我们能过浏览器打开地址，http://localhost:4000/. ##克隆主题 1$ git clone https://github.com/cnfeat/cnfeat.git themes/jacman ###启用主题修改Hexo目录下的config.yml配置文件中的theme属性，将其设置为jacman 注:最后一组改的属性 deploy: type: github repository: git@github.com:once00/once00.github.io.git branch: master ##推送 执行此命令进行保存推送到自己的github库 1$ hexo g 1$ hexo d ##Hexo命令 ###常用命令： 12345hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHub ###常用复合命令： 12hexo d -g #生成加部署hexo s -g #预览加部署 ###简写： 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 官方hexohttps://github.com/hexojs/hexo/wiki/Themes","tags":[]},{"title":"github下404问题的解决","date":"2015-01-15T09:12:03.000Z","path":"2015/01/15/github下404问题的解决/","text":"123456非常喜欢jekyll的简洁,特别是github下可以自动生成网页,但有的时候在本地是ok的,push到github无论如何总是显示404,检查各种设置也是正常的. 看 这里解决的方法很简单,打开项目的setting,点击 Automatic page generator,先使用自带的功能创建页面,然后打开 username.github.io,确认可以访问了以后,clone 项目后,删除已有文件,替换你自己的jekyll就可以了. 这里应该是github的一个bug了.","tags":[]}]